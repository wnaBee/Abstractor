				/*
				case "plus":
				comment += "Addition function object class ";
				break;
				case "minus":
				comment += "Subtraction function object class ";
				break;
				case "multiplies":
				comment += "Multiplication function object class ";
				break;
				case "divides":
				comment += "Division function object class ";
				break;
				case "modulus":
				comment += "Modulus function object class ";
				break;
				case "negate":
				comment += "Negative function object class ";
				break;
				case "equal_to":
				comment += "Function object class for equality comparison ";
				break;
				case "not_equal_to":
				comment += "Function object class for non-equality comparison ";
				break;
				case "greater":
				comment += "Function object class for greater-than inequality comparison ";
				break;
				case "less":
				comment += "Function object class for less-than inequality comparison ";
				break;
				case "greater_equal":
				comment += "Function object class for greater-than-or-equal-to comparison ";
				break;
				case "less_equal":
				comment += "Function object class for less-than-or-equal-to comparison ";
				break;
				case "logical_and":
				comment += "Logical AND function object class ";
				break;
				case "logical_or":
				comment += "Logical OR function object class ";
				break;
				case "logical_not":
				comment += "Logical NOT function object class ";
				break;
				case "Negators":
				comment += "Return negation of unary function object ";
				break;
				case "not1":
				comment += "Return negation of binary function object ";
				break;
				case "not2":
				comment += "Return function object with first parameter bound ";
				break;
				
				case "Return function object with second parameter bound ";:
				comment += ""
				break;
				case "bind1st":
				comment += "Convert function pointer to function object ";
				break;
				case "bind2nd":
				comment += "Convert member function to function object (pointer version) ";
				break;
				case "Conversors":
				comment += "Convert member function to function object (reference version) ";
				break;
				case "ptr_fun":
				comment += "Negate unary function object class ";
				break;
				case "mem_fun":
				comment += "Negate binary function object class ";
				break;
				case "mem_fun_ref":
				comment += "Generate function object class with 1st parameter bound ";
				break;
				case "unary_negate":
				comment += "Generate function object class with 2nd parameter bound ";
				break;
				case "binary_negate":
				comment += "Generate unary function object class from pointer ";
				break;
				case "binder1st":
				comment += "Generate binary function object class from pointer ";
				break;
				case "binder2nd":
				comment += "Generate function object class from parameterless member (pointer version) ";
				break;
				case "pointer_to_unary_function":
				comment += "Generate function object class from single-parameter member (pointer version) ";
				break;
				case "pointer_to_binary_function":
				comment += "Generate function object class from const parameterless member (pointer version) ";
				break;
				case "mem_fun_t":
				comment += "Generate function object class from single-parameter const member (pointer version) ";
				break;
				case "mem_fun1_t":
				comment += "Generate function object class from parameterless member (reference version) ";
				break;
				case "const_mem_fun_t":
				comment += "Generate function object class from single-parameter member (reference version) ";
				break;
				case "const_mem_fun1_t":
				comment += "Generate function object class from const parameterless member (reference version) ";
				break;
				case "mem_fun_ref_t":
				comment += "Generate function object class from single-parameter const member (reference version) ";
				break;
				case "mem_fun1_ref_t":
				comment += "Bind function arguments ";
				break;
				case "const_mem_fun_ref_t":
				comment += "Construct reference_wrapper to const ";
				break;
				case "const_mem_fun1_ref_t":
				comment += "Convert member function to function object ";
				break;
				case "bind":
				comment += "Return negation of unary function object ";
				break;
				case "cref":
				comment += "Return negation of binary function object ";
				break;
				case "mem_fn":
				comment += "Construct reference_wrapper ";
				break;
				case "not1":
				comment += "Negate binary function object class ";
				break;
				case "not2":
				comment += "Function wrapper ";
				break;
				case "ref":
				comment += "Reference wrapper ";
				break;
				case "binary_negate":
				comment += "Negate unary function object class ";
				break;
				case "function":
				comment += "Bitwise AND function object class ";
				break;
				case "reference_wrapper":
				comment += "Bitwise OR function object class ";
				break;
				case "unary_negate":
				comment += "Bitwise XOR function object class ";
				break;
				case "bit_and":
				comment += "Division function object class ";
				break;
				case "bit_or":
				comment += "Function object class for equality comparison ";
				break;
				case "bit_xor":
				comment += "Function object class for greater-than inequality comparison ";
				break;
				case "divides":
				comment += "Function object class for greater-than-or-equal-to comparison ";
				break;
				case "equal_to":
				comment += "Function object class for less-than inequality comparison ";
				break;
				case "greater":
				comment += "Function object class for less-than-or-equal-to comparison ";
				break;
				case "greater_equal":
				comment += "Logical AND function object class ";
				break;
				case "less":
				comment += "Logical NOT function object class ";
				break;
				case "less_equal":
				comment += "Logical OR function object class ";
				break;
				case "logical_and":
				comment += "Subtraction function object class ";
				break;
				case "logical_not":
				comment += "Modulus function object class ";
				break;
				case "logical_or":
				comment += "Multiplication function object class ";
				break;
				case "minus":
				comment += "Negative function object class ";
				break;
				case "modulus":
				comment += "Function object class for non-equality comparison ";
				break;
				case "multiplies":
				comment += "Addition function object class ";
				break;
				case "negate":
				comment += "Exception thrown on bad call ";
				break;
				case "not_equal_to":
				comment += "Default hash function object class ";
				break;
				case "plus":
				comment += "Is bind expression ";
				break;
				case "bad_function_call":
				comment += "Is placeholder ";
				break;
				case "hash":
				comment += "Bind argument placeholders ";
				break;
				case "is_bind_expression":
				comment += ""
				break;
				case "is_placeholder":
				comment += ""
				break;
				case "placeholders":
				comment += ""
				break;
		*/
		
		
		
		/*
				case "Generic":
				comment += "relational"
				break;
				case "operators":
				comment += "Exchange values of two objects ";
				break;
				case "Rvalue":
				comment += "casts"
				break;
				case "(C++11)":
				comment += "Construct pair object ";
				break;
				case "Generic":
				comment += "swap"
				break;
				case "function":
				comment += "Forward argument ";
				break;
				case "swap":
				comment += "Move as rvalue ";
				break;
				case "make_pair":
				comment += "Move if noexcept ";
				break;
				case "forward":
				comment += "Declaration value ";
				break;
				case "move":
				comment += "Pair of values ";
				break;
				case "move_if_noexcept":
				comment += "Piecewise construct type ";
				break;
				case "declval":
				comment += "Piecewise construct constant ";
				break;
				case "pair":
				comment += "Relational Operators ";
				break;
				case "piecewise_construct_t":
				comment += ""
				break;
				case "piecewise_construct":
				comment += ""
				break;
				case "rel_ops":
				comment += ""
				break;
